<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>ANVA – TUG (Keypoints-only + Tape + Replay)</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />

  <style>
    body { font-family: Arial, sans-serif; background:#f6f7f9; text-align:center; padding:16px; }
    h1 { color:#0b5ed7; margin: 8px 0 14px; }
    #wrap { width:100%; max-width:420px; margin:0 auto; }

    #stage{
      position:relative;
      width:100%;
      aspect-ratio: 9 / 16;
      border-radius:12px;
      overflow:hidden;
      background:#111;
      box-shadow: 0 6px 18px rgba(0,0,0,.12);
      touch-action: manipulation;
    }

    video, canvas{
      position:absolute;
      inset:0;
      width:100%;
      height:100%;
      object-fit: cover;
    }

    /* UI */
    .row { display:flex; gap:10px; justify-content:center; margin-top:12px; flex-wrap:wrap; }
    button {
      padding:12px 14px; border:0; border-radius:10px; font-weight:700;
      background:#0b5ed7; color:#fff; cursor:pointer;
    }
    button:disabled { background:#9bb7e9; cursor:not-allowed; }
    .ghost { background:#fff; color:#0b5ed7; border:2px solid #0b5ed7; }
    .danger { background:#dc3545; }
    .ok { background:#198754; }
    #status {
      margin-top:10px; font-size:13px; line-height:1.35; color:#222;
      background:#fff; border-radius:10px; padding:10px 12px; text-align:left;
      border:1px solid #e6e8ee;
    }
    .pill { display:inline-block; padding:3px 8px; border-radius:999px; font-weight:700; font-size:12px; }
    .pill-ok { background:#d1e7dd; color:#0f5132; }
    .pill-warn { background:#fff3cd; color:#664d03; }
    .pill-bad { background:#f8d7da; color:#842029; }
    .small { font-size:12px; color:#555; }

    /* Hide stage until camera started */
    #stage { display:none; }

    /* Replay canvas only mode */
    #replayHint { margin-top:8px; font-size:12px; color:#444; display:none; }
  </style>

  <!-- TensorFlow.js + Pose Detection (MoveNet) -->
  <script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs@4.22.0/dist/tf.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/@tensorflow-models/pose-detection@2.1.3/dist/pose-detection.min.js"></script>
</head>

<body>
  <div id="wrap">
    <h1>ANVA – TUG</h1>

    <div class="small">
      Privacy: <span class="pill pill-ok">NO camera pixels saved</span> · Output: <span class="pill pill-ok">Keypoints JSON only</span><br>
      Tap the blue tape line on screen to set the turn marker. Record unlocks only after validity is green.
    </div>

    <div id="stage">
      <video id="video" playsinline muted></video>
      <canvas id="canvas"></canvas>
    </div>

    <div class="row">
      <button id="btnCam" class="ok">Start Camera</button>
      <button id="btnTape" class="ghost" disabled>Set Tape (Tap Line)</button>
      <button id="btnRecord" disabled>Record TUG</button>
      <button id="btnStop" class="danger" disabled>Stop</button>
      <button id="btnDownload" class="ghost" disabled>Download JSON</button>
    </div>

    <div id="replayHint">Replay mode: after recording, tap “Record TUG” again to view replay on the same canvas (no video stored).</div>

    <div id="status">
      <div><b>Status:</b> <span id="stText">Idle</span></div>
      <div class="small" id="stDetail"></div>
    </div>
  </div>

<script>
(() => {
  // -----------------------------
  // Locked instrument constants
  // -----------------------------
  const CFG = {
    version: "ANVA_TUG_KEYPOINTS_v2",
    minScore: 0.35,            // (5) confidence gating threshold
    maxInterpGapMs: 250,       // (8) bounded interpolation allowed gap
    drawFps: 30,               // display smoothing
    filterWindow: 5,           // (9) simple median window for display only
    requireFeetVisible: true,  // (11) visibility monitoring
    requireTapeSet: true,      // (1) tape alignment required before record
    requireFullBody: true,     // (11) basic sanity: hips+knees+ankles
    // (3)(4) timing truth = performance.now monotonic
  };

  // -----------------------------
  // DOM
  // -----------------------------
  const stage = document.getElementById("stage");
  const video = document.getElementById("video");
  const canvas = document.getElementById("canvas");
  const ctx = canvas.getContext("2d");

  const btnCam = document.getElementById("btnCam");
  const btnTape = document.getElementById("btnTape");
  const btnRecord = document.getElementById("btnRecord");
  const btnStop = document.getElementById("btnStop");
  const btnDownload = document.getElementById("btnDownload");

  const stText = document.getElementById("stText");
  const stDetail = document.getElementById("stDetail");
  const replayHint = document.getElementById("replayHint");

  // -----------------------------
  // State
  // -----------------------------
  let detector = null;
  let stream = null;

  let tapeYNorm = null;           // (1) tape reference in normalized viewport coordinates (0..1)
  let tapeWasSetByUser = false;

  let isTapeSetMode = false;
  let isRecording = false;
  let isReplayMode = false;

  // frames recorded: {t_ms, tape_y_norm, kps:[{x,y,s}...], validity:{...}}
  let recorded = [];
  let recordStartMs = null;

  // for dropout handling
  let lastGoodFrame = null;

  // replay index
  let replayIdx = 0;
  let replayTimer = null;

  // 17-keypoint mapping (MoveNet / BlazePose style indexes differ by model; pose-detection returns named keypoints)
  // We'll store only {x,y,score} in a stable order based on "name".
  const KEY_ORDER = [
    "nose","left_eye","right_eye","left_ear","right_ear",
    "left_shoulder","right_shoulder","left_elbow","right_elbow",
    "left_wrist","right_wrist","left_hip","right_hip",
    "left_knee","right_knee","left_ankle","right_ankle"
  ];

  function setStatus(main, detail="") {
    stText.textContent = main;
    stDetail.textContent = detail;
  }

  // -----------------------------
  // Utilities
  // -----------------------------
  function clamp01(x){ return Math.max(0, Math.min(1, x)); }

  function resizeCanvasToVideo() {
    const rect = stage.getBoundingClientRect();
    canvas.width = Math.round(rect.width);
    canvas.height = Math.round(rect.height);
  }

  // (6) normalize to viewport; we store normalized positions to remove device size
  function toNorm(xPx, yPx) {
    return { x: xPx / canvas.width, y: yPx / canvas.height };
  }

  function fromNorm(x, y) {
    return { x: x * canvas.width, y: y * canvas.height };
  }

  function median(arr) {
    const a = arr.slice().sort((p,q)=>p-q);
    const m = Math.floor(a.length/2);
    return a.length % 2 ? a[m] : (a[m-1]+a[m])/2;
  }

  // (9) display-only smoothing (never alters raw recorded truth unless you explicitly choose to)
  function medianFilterKps(frameList, idx, win) {
    const half = Math.floor(win/2);
    const xs = [], ys = [], ss = [];
    for (let k=idx-half; k<=idx+half; k++){
      if (k<0 || k>=frameList.length) continue;
      const kp = frameList[k];
      xs.push(kp.x); ys.push(kp.y); ss.push(kp.s);
    }
    return { x: median(xs), y: median(ys), s: median(ss) };
  }

  // (11)(5) determine if key landmarks are visible with confidence gating
  function visibilityReport(kpsByName) {
    const need = ["left_hip","right_hip","left_knee","right_knee","left_ankle","right_ankle"];
    const missing = [];
    for (const n of need) {
      const kp = kpsByName[n];
      if (!kp || kp.score < CFG.minScore) missing.push(n);
    }
    const ok = missing.length === 0;
    return { ok, missing };
  }

  // (7)(8) dropout handling + bounded interpolation:
  // - if a frame is missing/low conf, we can carry-forward for DISPLAY
  // - but for RECORD we flag invalid or interpolated with bounds
  function boundedInterp(prev, curr, dtMs) {
    // if gap too large => no fabrication
    if (!prev || !curr || dtMs > CFG.maxInterpGapMs) return null;
    // linear interpolation for each kp
    const out = {};
    for (const name of KEY_ORDER) {
      const a = prev[name], b = curr[name];
      if (!a || !b) continue;
      out[name] = {
        x: a.x + (b.x-a.x)*0.5,
        y: a.y + (b.y-a.y)*0.5,
        score: Math.min(a.score, b.score)
      };
    }
    return out;
  }

  function keypointsToStableArray(kpsByName) {
    return KEY_ORDER.map(n => {
      const kp = kpsByName[n];
      if (!kp) return { x: NaN, y: NaN, s: 0 };
      return { x: kp.x, y: kp.y, s: kp.score };
    });
  }

  function stableArrayToByName(arr) {
    const m = {};
    for (let i=0;i<KEY_ORDER.length;i++){
      m[KEY_ORDER[i]] = { x: arr[i].x, y: arr[i].y, score: arr[i].s };
    }
    return m;
  }

  function nowMsMonotonic() {
    // (4) monotonic clock: independent of FPS, avoids “timing lies”
    return performance.now();
  }

  // -----------------------------
  // Tape set: DOM-measured (the tap point in stage maps to normalized Y)
  // -----------------------------
  function enterTapeSetMode() {
    isTapeSetMode = true;
    setStatus("Tape set mode", "Tap anywhere on the video/canvas where the blue tape line is on the floor.");
  }

  function exitTapeSetMode() {
    isTapeSetMode = false;
    setStatus("Live", tapeYNorm !== null ? `Tape locked at y_norm=${tapeYNorm.toFixed(4)}` : "");
  }

  function onStageTap(ev) {
    const rect = stage.getBoundingClientRect();
    const clientY = (ev.touches && ev.touches[0]) ? ev.touches[0].clientY : ev.clientY;
    const y = (clientY - rect.top) / rect.height;
    const yN = clamp01(y);

    if (isTapeSetMode) {
      tapeYNorm = yN;
      tapeWasSetByUser = true;
      exitTapeSetMode();
      // (1) tape alignment now defined; allow record if other validity conditions pass
      btnRecord.disabled = !isGreenValid();
      btnTape.textContent = "Tape Locked";
      btnTape.disabled = false;
      setStatus("Tape locked", `Blue tape reference locked at y_norm=${tapeYNorm.toFixed(4)}. Record will unlock when pose validity is green.`);
      return;
    }

    // Optional: quick toggle into tape set mode if user taps near existing line
    // (kept conservative to avoid accidental changes)
  }

  // -----------------------------
  // Green validity gate (instrument protection)
  // -----------------------------
  function isGreenValid(lastPoseByName=null) {
    // (40) validity gates: do not allow recording if prerequisites are missing
    if (CFG.requireTapeSet && tapeYNorm === null) return false;
    if (!lastPoseByName) return false;

    const vis = visibilityReport(lastPoseByName);
    if (CFG.requireFullBody && !vis.ok) return false;

    // (11) if feet required, ensure ankles valid
    if (CFG.requireFeetVisible) {
      const la = lastPoseByName["left_ankle"], ra = lastPoseByName["right_ankle"];
      if (!la || !ra) return false;
      if (la.score < CFG.minScore || ra.score < CFG.minScore) return false;
    }
    return true;
  }

  // -----------------------------
  // Draw helpers (skeleton + tape)
  // -----------------------------
  function drawTape() {
    if (tapeYNorm === null) return;
    const y = tapeYNorm * canvas.height;
    ctx.save();
    ctx.lineWidth = 4;
    ctx.strokeStyle = "rgba(0, 140, 255, 0.95)";
    ctx.beginPath();
    ctx.moveTo(0, y);
    ctx.lineTo(canvas.width, y);
    ctx.stroke();
    ctx.restore();
  }

  function drawSkeleton(kpsByName, useFiltered=false) {
    // Build stable array
    const stable = keypointsToStableArray(kpsByName);

    // Apply display median filter across the *latest recorded* if requested
    // For live display we do light smoothing by using lastGoodFrame (not altering recorded truth)
    let disp = stable;
    if (useFiltered && lastGoodFrame && lastGoodFrame._stable) {
      // simple: average current with lastGood for display
      disp = disp.map((p, i) => {
        const q = lastGoodFrame._stable[i];
        if (!q) return p;
        return {
          x: (p.x + q.x)/2,
          y: (p.y + q.y)/2,
          s: Math.min(p.s, q.s)
        };
      });
    }

    const byName = stableArrayToByName(disp);

    // Connections (basic)
    const edges = [
      ["left_shoulder","right_shoulder"],
      ["left_shoulder","left_elbow"],
      ["left_elbow","left_wrist"],
      ["right_shoulder","right_elbow"],
      ["right_elbow","right_wrist"],
      ["left_shoulder","left_hip"],
      ["right_shoulder","right_hip"],
      ["left_hip","right_hip"],
      ["left_hip","left_knee"],
      ["left_knee","left_ankle"],
      ["right_hip","right_knee"],
      ["right_knee","right_ankle"]
    ];

    ctx.save();
    ctx.lineWidth = 3;
    ctx.strokeStyle = "rgba(0, 255, 170, 0.90)";
    ctx.fillStyle = "rgba(0, 255, 170, 0.90)";

    // edges
    for (const [a,b] of edges) {
      const A = byName[a], B = byName[b];
      if (!A || !B) continue;
      if (A.score < CFG.minScore || B.score < CFG.minScore) continue;
      const pA = fromNorm(A.x, A.y);
      const pB = fromNorm(B.x, B.y);
      ctx.beginPath();
      ctx.moveTo(pA.x, pA.y);
      ctx.lineTo(pB.x, pB.y);
      ctx.stroke();
    }

    // points (hips/knees/ankles emphasized)
    const points = ["left_hip","right_hip","left_knee","right_knee","left_ankle","right_ankle"];
    for (const n of points) {
      const P = byName[n];
      if (!P || P.score < CFG.minScore) continue;
      const p = fromNorm(P.x, P.y);
      ctx.beginPath();
      ctx.arc(p.x, p.y, 5, 0, Math.PI*2);
      ctx.fill();
    }

    ctx.restore();
  }

  function drawGreenGateBox(ok) {
    // Simple top banner indicator instead of a box (low cognitive load)
    ctx.save();
    ctx.globalAlpha = 0.85;
    ctx.fillStyle = ok ? "rgba(25, 135, 84, 0.85)" : "rgba(220, 53, 69, 0.85)";
    ctx.fillRect(0, 0, canvas.width, 36);
    ctx.fillStyle = "white";
    ctx.font = "bold 14px Arial";
    ctx.fillText(ok ? "GREEN: Valid setup (Record unlocked)" : "RED: Fix setup (Tape + full body + feet)", 10, 23);
    ctx.restore();
  }

  // -----------------------------
  // Core loop
  // -----------------------------
  let rafId = null;

  async function loop() {
    if (!detector || video.readyState < 2) {
      rafId = requestAnimationFrame(loop);
      return;
    }

    resizeCanvasToVideo();
    ctx.clearRect(0, 0, canvas.width, canvas.height);

    // draw tape first
    drawTape();

    // estimate pose
    let poses = [];
    try {
      poses = await detector.estimatePoses(video, { maxPoses: 1, flipHorizontal: true });
    } catch (e) {
      setStatus("Pose error", String(e));
      rafId = requestAnimationFrame(loop);
      return;
    }

    let pose = poses && poses[0] ? poses[0] : null;
    let kpsByName = {};

    if (pose && pose.keypoints) {
      // Convert pixel coords -> normalized (6)
      for (const kp of pose.keypoints) {
        if (!kp.name) continue;
        const n = toNorm(kp.x, kp.y);
        kpsByName[kp.name] = { x: n.x, y: n.y, score: kp.score ?? 0 };
      }
    }

    // Dropout handling (7)
    const vis = visibilityReport(kpsByName);
    const green = isGreenValid(kpsByName);

    // Draw skeleton (filtered display)
    if (pose) drawSkeleton(kpsByName, true);

    // Gate banner
    drawGreenGateBox(green);

    // Status text
    if (!tapeWasSetByUser) {
      setStatus("Live", "Tap “Set Tape” then tap the blue tape line on screen to lock it.");
    } else if (!vis.ok) {
      setStatus("Live", `Missing landmarks: ${vis.missing.join(", ")}`);
    } else {
      setStatus("Live", green ? "Valid setup. You can record." : "Fix setup until green.");
    }

    // Enable/disable Record dynamically
    if (!isRecording && !isReplayMode) {
      btnRecord.disabled = !green;
    }

    // (3)(4) Pose frame as measurement unit + monotonic clock for recording
    if (isRecording) {
      const tNow = nowMsMonotonic();
      const tRel = Math.round(tNow - recordStartMs);

      // Build stable array
      const stable = keypointsToStableArray(kpsByName);

      // Determine validity flags (40)(42)
      const validity = {
        tape_set: tapeYNorm !== null,
        full_body_ok: vis.ok,
        feet_ok: true,
        conf_ok: true,
        interpolated: false,
        dropout: false
      };

      // Check ankle confidence
      const la = kpsByName["left_ankle"], ra = kpsByName["right_ankle"];
      if (!la || !ra || la.score < CFG.minScore || ra.score < CFG.minScore) validity.feet_ok = false;

      // Check overall confidence
      for (const p of stable) {
        if (p.s > 0 && p.s < CFG.minScore) { validity.conf_ok = false; break; }
      }

      // If visibility fails, attempt bounded interpolation (8) ONLY for continuity,
      // but we still mark the frame invalid so downstream math can refuse hallucinations.
      if (!vis.ok) {
        validity.dropout = true;

        // If we have lastGoodFrame and current pose is low quality, do not fabricate raw truth.
        // Downstream analysis can choose to interpolate within bounds.
      } else {
        // good pose
        lastGoodFrame = { tRel, _stable: stable, byName: kpsByName };
      }

      recorded.push({
        t_ms: tRel,
        tape_y_norm: tapeYNorm,
        kps: stable.map(p => ({ x: p.x, y: p.y, s: p.s })),
        validity
      });
    }

    rafId = requestAnimationFrame(loop);
  }

  // -----------------------------
  // Replay (41): stick-figure replay from JSON frames
  // -----------------------------
  function startReplay() {
    if (!recorded.length) return;
    isReplayMode = true;
    replayHint.style.display = "block";
    btnStop.disabled = true;
    btnTape.disabled = true;
    btnRecord.disabled = true;
    btnDownload.disabled = false;

    replayIdx = 0;
    setStatus("Replay", "Rendering stick-figure replay from recorded keypoints (no video stored).");

    if (replayTimer) clearInterval(replayTimer);
    replayTimer = setInterval(() => {
      resizeCanvasToVideo();
      ctx.clearRect(0, 0, canvas.width, canvas.height);
      drawTape();

      const fr = recorded[replayIdx];
      if (!fr) {
        clearInterval(replayTimer);
        replayTimer = null;
        isReplayMode = false;
        btnTape.disabled = false;
        btnRecord.disabled = false;
        setStatus("Replay done", "You can set tape again or record another trial.");
        return;
      }

      const byName = stableArrayToByName(fr.kps.map(p => ({x:p.x, y:p.y, s:p.s})));
      drawSkeleton(byName, false);

      // show validity on banner
      const ok = fr.validity.tape_set && fr.validity.full_body_ok && fr.validity.feet_ok;
      drawGreenGateBox(ok);

      replayIdx++;
    }, Math.round(1000 / CFG.drawFps));
  }

  // -----------------------------
  // Camera / model init
  // -----------------------------
  async function startCamera() {
    setStatus("Starting camera...", "");
    stage.style.display = "block";
    resizeCanvasToVideo();

    // Try WebGL for speed; fall back to CPU
    try { await tf.setBackend("webgl"); await tf.ready(); }
    catch { await tf.setBackend("cpu"); await tf.ready(); }

    try {
      stream = await navigator.mediaDevices.getUserMedia({
        video: {
          facingMode: "user",
          width: { ideal: 720 },
          height: { ideal: 1280 }
        },
        audio: false
      });
    } catch (e) {
      setStatus("Camera blocked", "Enable camera permissions in iOS Settings / browser.");
      return;
    }

    video.srcObject = stream;
    await video.play();

    // Create MoveNet detector
    setStatus("Loading pose model...", "");
    detector = await poseDetection.createDetector(
      poseDetection.SupportedModels.MoveNet,
      { modelType: poseDetection.movenet.modelType.SINGLEPOSE_LIGHTNING }
    );

    setStatus("Live", "Tap “Set Tape” then tap the blue tape line on screen to lock it.");
    btnTape.disabled = false;
    btnCam.disabled = true;

    // Start loop
    if (rafId) cancelAnimationFrame(rafId);
    rafId = requestAnimationFrame(loop);
  }

  // -----------------------------
  // Record controls
  // -----------------------------
  function startRecording() {
    if (isReplayMode) return;

    // If we already have a recording, a second press goes to replay (simple clinician workflow)
    if (recorded.length && !isRecording) {
      startReplay();
      return;
    }

    recorded = [];
    lastGoodFrame = null;
    recordStartMs = nowMsMonotonic();
    isRecording = true;

    btnRecord.disabled = true;
    btnStop.disabled = false;
    btnTape.disabled = true;
    btnDownload.disabled = true;

    setStatus("Recording", "Capturing keypoints time-series (monotonic time).");
  }

  function stopRecording() {
    isRecording = false;

    btnStop.disabled = true;
    btnTape.disabled = false;
    btnDownload.disabled = recorded.length === 0;
    btnRecord.disabled = false;

    // (42) discrepancy detection: flag if too short, too many invalid frames, etc.
    const n = recorded.length;
    let invalid = 0;
    for (const fr of recorded) {
      const ok = fr.validity.tape_set && fr.validity.full_body_ok && fr.validity.feet_ok;
      if (!ok) invalid++;
    }
    const invalidPct = n ? Math.round((invalid/n)*100) : 100;

    setStatus(
      "Stopped",
      `Frames: ${n}. Invalid frames: ${invalid} (${invalidPct}%). Download JSON or press Record again for replay.`
    );
    replayHint.style.display = "block";
  }

  function downloadJSON() {
    if (!recorded.length) return;

    // (2) pixel → skeleton transition enforced: we export NO pixels, ONLY numbers.
    const payload = {
      version: CFG.version,
      created_iso: new Date().toISOString(),
      tape_set: tapeWasSetByUser,
      tape_y_norm: tapeYNorm,
      minScore: CFG.minScore,
      maxInterpGapMs: CFG.maxInterpGapMs,
      key_order: KEY_ORDER,
      frames: recorded
    };

    const blob = new Blob([JSON.stringify(payload)], { type:"application/json" });
    const url = URL.createObjectURL(blob);

    const a = document.createElement("a");
    a.href = url;
    a.download = `ANVA_TUG_KEYPOINTS_${new Date().toISOString().replace(/[:.]/g,"-")}.json`;
    document.body.appendChild(a);
    a.click();
    a.remove();

    URL.revokeObjectURL(url);
    setStatus("Downloaded", "JSON saved. No camera pixels were stored.");
  }

  // -----------------------------
  // Wiring
  // -----------------------------
  btnCam.addEventListener("click", startCamera);

  btnTape.addEventListener("click", () => {
    if (!detector) return;
    btnTape.textContent = "Tap Tape Line Now";
    enterTapeSetMode();
  });

  btnRecord.addEventListener("click", startRecording);
  btnStop.addEventListener("click", stopRecording);
  btnDownload.addEventListener("click", downloadJSON);

  // Tap on stage to set tape Y (DOM mapped)
  stage.addEventListener("click", onStageTap);
  stage.addEventListener("touchstart", onStageTap, { passive:true });

  window.addEventListener("resize", () => resizeCanvasToVideo());

  setStatus("Idle", "Press Start Camera.");
})();
</script>
</body>
</html>
