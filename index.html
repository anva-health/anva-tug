<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, viewport-fit=cover" />
  <title>ANVA — TUG (Privacy Special)</title>
  <style>
    :root{ --brand:#0b5ed7; --ok:#1e8e3e; --warn:#b3261e; --bg:#f6f7f9; --card:#fff; --muted:#6b7280; }
    body{ margin:0; font-family:system-ui,-apple-system,Segoe UI,Roboto,Arial,sans-serif; background:var(--bg); padding:14px; color:#111827; text-align:center;}
    h1{ margin:10px 0 6px; font-size:22px; color:var(--brand); font-weight:900; letter-spacing:.2px;}
    .sub{ margin:0 0 12px; font-size:13px; color:var(--muted); font-weight:700;}
    .card{ max-width:520px; margin:0 auto; background:var(--card); border-radius:16px; padding:14px; box-shadow:0 10px 30px rgba(0,0,0,.07);}
    .hint{ font-size:13px; color:#111827; line-height:1.35; margin:8px 0 10px; text-align:left;}
    .hint b{ font-weight:900; }
    .row{ display:flex; gap:10px; justify-content:center; flex-wrap:wrap; margin-top:10px;}
    button{ border:0; border-radius:12px; padding:12px 14px; font-size:14px; font-weight:800; cursor:pointer; background:var(--brand); color:#fff; min-width:150px;}
    button.secondary{ background:#111827; }
    button.good{ background:var(--ok); }
    button.danger{ background:var(--warn); }
    button:disabled{ opacity:.45; cursor:not-allowed; }

    #stage{ position:relative; width:100%; max-width:480px; margin:12px auto 0; border-radius:14px; overflow:hidden; background:#000; display:none;}
    video, canvas{ width:100%; height:auto; display:block; background:#000; }
    #pill{
      position:absolute; left:10px; top:10px; z-index:5;
      padding:6px 10px; border-radius:999px; font-size:12px;
      color:#fff; background:rgba(0,0,0,.55);
    }

    .tog{ display:flex; justify-content:space-between; align-items:center; gap:10px; margin-top:10px; font-size:13px; color:var(--muted); text-align:left;}
    input[type="checkbox"]{ transform:scale(1.2); }

    a.dl{ display:none; margin-top:12px; font-weight:900; color:var(--brand); text-decoration:none; word-break:break-word; }
    .full{ width:100%; max-width:520px; }
    .msg{ margin-top:10px; font-size:13px; font-weight:800; color:var(--muted); text-align:left; }
    .err{ color:var(--warn); }
  </style>
</head>

<body>
  <h1>ANVA — TUG (Privacy Special)</h1>
  <p class="sub">Pose-only capture. No video/images saved. Outputs: keypoints JSON (+ optional stick-video).</p>

  <div class="card">
    <div class="hint">
      <b>Privacy:</b> Live camera preview is allowed; <b>no camera pixels are saved</b>.<br/>
      <b>Setup:</b> Frontal view, full body below neck + feet visible.
    </div>

    <div class="row">
      <button id="btnStart">Start Camera</button>
      <button id="btnSwitch" class="secondary" disabled>Switch Camera</button>
    </div>

    <div id="stage">
      <div id="pill">Loading…</div>
      <video id="vid" playsinline muted></video>
      <canvas id="viz"></canvas>
    </div>

    <div class="tog">
      <label><input id="chkShowVideo" type="checkbox" /> Show live video under stick figure (preview only)</label>
    </div>
    <div class="tog">
      <label><input id="chkRecordStick" type="checkbox" checked /> Record stick figure-only video (no pixels) as WebM</label>
    </div>

    <div class="row">
      <button id="btnArm" class="good" disabled>Setup Looks Good</button>
      <button id="btnGo" class="danger" disabled>Start Capture</button>
      <button id="btnStop" class="secondary" disabled>Stop</button>
    </div>

    <a id="dlJson" class="dl" download>Download keypoints JSON</a>
    <button id="btnDrive" class="good full" style="display:none; margin-top:10px;">
      Save keypoints to Google Drive
    </button>
    <a id="dlWebm" class="dl" download>Download stick-figure video</a>

    <div id="status" class="msg"></div>
    <div id="detail" class="msg"></div>
  </div>

  <script>
    // =========================
    // CONFIG (no on-screen tape line)
    // =========================
    // This is only stored in JSON meta for later tape-crossing logic.
    // It means "a fixed y-position in the camera frame", expressed as a fraction of height.
    // We'll calibrate this later from a real taped trial if needed.
    const TAPE_Y_NORM = 0.70;

    // =========================
    // SAFARI-SAFE LIBRARY LOADER
    // =========================
    function loadScript(src) {
      return new Promise((resolve, reject) => {
        const s = document.createElement("script");
        s.src = src;
        s.async = true;
        s.onload = () => resolve(true);
        s.onerror = () => reject(new Error("Failed to load: " + src));
        document.head.appendChild(s);
      });
    }

    async function ensureLibraries() {
      const TFJS = "https://cdn.jsdelivr.net/npm/@tensorflow/tfjs@4.17.0/dist/tf.min.js";
      const PD   = "https://cdn.jsdelivr.net/npm/@tensorflow-models/pose-detection@2.1.3/dist/pose-detection.min.js";

      await loadScript(TFJS);
      await loadScript(PD);

      // Safari sometimes delays global availability
      const tStart = performance.now();
      while (performance.now() - tStart < 3000) {
        if (window.tf && window.poseDetection) return true;
        await new Promise(r => setTimeout(r, 50));
      }
      throw new Error("Libraries loaded but globals missing (tf/poseDetection).");
    }

    // =========================
    // APP
    // =========================
    (async () => {
      const btnStart  = document.getElementById("btnStart");
      const btnSwitch = document.getElementById("btnSwitch");
      const btnArm    = document.getElementById("btnArm");
      const btnGo     = document.getElementById("btnGo");
      const btnStop   = document.getElementById("btnStop");

      const vid = document.getElementById("vid");
      const stage = document.getElementById("stage");
      const pill = document.getElementById("pill");
      const canvas = document.getElementById("viz");
      const ctx = canvas.getContext("2d");

      const chkShowVideo = document.getElementById("chkShowVideo");
      const chkRecordStick = document.getElementById("chkRecordStick");

      const dlJson = document.getElementById("dlJson");
      const dlWebm = document.getElementById("dlWebm");
      const btnDrive = document.getElementById("btnDrive");

      const status = document.getElementById("status");
      const detail = document.getElementById("detail");

      let stream = null;
      let useRear = true;
      let detector = null;

      let raf = null;
      let armed = false;
      let capturing = false;

      let frames = [];
      let t0 = null;

      // Canvas-only recording (stick figure)
      let rec = null;
      let recChunks = [];

      // Share state
      let lastJsonBlob = null;
      let lastJsonName = null;

      function setPill(text, bg='rgba(0,0,0,.55)'){ pill.textContent=text; pill.style.background=bg; }
      function setStatus(text, isErr=false){
        status.textContent = text || "";
        status.className = "msg" + (isErr ? " err" : "");
      }

      function resizeCanvas() {
        const vw = vid.videoWidth || 1280;
        const vh = vid.videoHeight || 720;
        canvas.width = vw;
        canvas.height = vh;
      }

      async function initDetector() {
        setPill("Loading MoveNet…");
        await tf.ready();
        try { await tf.setBackend("webgl"); } catch(e) {}

        detector = await poseDetection.createDetector(
          poseDetection.SupportedModels.MoveNet,
          { modelType: poseDetection.movenet.modelType.SINGLEPOSE_LIGHTNING, enableSmoothing: true }
        );
        setPill("Model ready", "rgba(30,142,62,.85)");
      }

      function kpMap(keypoints) {
        const m = new Map();
        for (const k of keypoints) m.set(k.name, k);
        return m;
      }

      const EDGES = [
        ["left_shoulder","right_shoulder"],
        ["left_shoulder","left_elbow"],["left_elbow","left_wrist"],
        ["right_shoulder","right_elbow"],["right_elbow","right_wrist"],
        ["left_shoulder","left_hip"],["right_shoulder","right_hip"],
        ["left_hip","right_hip"],
        ["left_hip","left_knee"],["left_knee","left_ankle"],
        ["right_hip","right_knee"],["right_knee","right_ankle"]
      ];

      function drawStick(keypoints) {
        const m = kpMap(keypoints);

        ctx.clearRect(0,0,canvas.width,canvas.height);

        if (chkShowVideo.checked) {
          ctx.globalAlpha = 0.30;
          ctx.drawImage(vid, 0, 0, canvas.width, canvas.height);
          ctx.globalAlpha = 1.0;
        } else {
          ctx.fillStyle = "#000";
          ctx.fillRect(0,0,canvas.width,canvas.height);
        }

        // Skeleton edges
        ctx.save();
        ctx.strokeStyle = "rgba(255,255,255,0.9)";
        ctx.lineWidth = Math.max(4, Math.floor(canvas.width * 0.006));
        for (const [a,b] of EDGES) {
          const A = m.get(a), B = m.get(b);
          if (!A || !B) continue;
          if ((A.score ?? 0) < 0.2 || (B.score ?? 0) < 0.2) continue;
          ctx.beginPath();
          ctx.moveTo(A.x, A.y);
          ctx.lineTo(B.x, B.y);
          ctx.stroke();
        }
        ctx.restore();

        // Joints
        ctx.save();
        ctx.fillStyle = "rgba(255,255,255,0.95)";
        const r = Math.max(3, Math.floor(canvas.width * 0.006));
        for (const k of keypoints) {
          if ((k.score ?? 0) < 0.2) continue;
          ctx.beginPath();
          ctx.arc(k.x, k.y, r, 0, Math.PI*2);
          ctx.fill();
        }
        ctx.restore();
      }

      function startStickRecording() {
        recChunks = [];
        const cs = canvas.captureStream(30);
        const mimeTypes = ["video/webm;codecs=vp9","video/webm;codecs=vp8","video/webm"];
        let chosen = "";
        for (const mt of mimeTypes) if (MediaRecorder.isTypeSupported(mt)) { chosen = mt; break; }
        rec = new MediaRecorder(cs, chosen ? { mimeType: chosen } : {});
        rec.ondataavailable = (e) => { if (e.data && e.data.size > 0) recChunks.push(e.data); };
        rec.start(250);
      }

      function stopStickRecording() {
        return new Promise((resolve) => {
          if (!rec || rec.state === "inactive") return resolve(null);
          rec.onstop = () => resolve(new Blob(recChunks, { type: rec.mimeType || "video/webm" }));
          rec.stop();
        });
      }

      async function startCamera() {
        // reset
        dlJson.style.display = "none";
        dlWebm.style.display = "none";
        btnDrive.style.display = "none";
        detail.textContent = "";

        frames = [];
        t0 = null;
        armed = false;
        capturing = false;
        lastJsonBlob = null;
        lastJsonName = null;

        if (stream) { stream.getTracks().forEach(t => t.stop()); stream=null; }

        setStatus("Requesting camera…");
        setPill("Requesting camera…");

        stream = await navigator.mediaDevices.getUserMedia({
          audio:false,
          video:{
            facingMode: useRear ? { ideal:"environment" } : { ideal:"user" },
            width:{ ideal:1280 },
            height:{ ideal:720 }
          }
        });

        vid.srcObject = stream;
        await vid.play();

        stage.style.display = "block";
        btnSwitch.disabled = false;
        btnArm.disabled = false;
        btnGo.disabled = true;
        btnStop.disabled = true;

        resizeCanvas();

        if (!detector) await initDetector();

        if (raf) cancelAnimationFrame(raf);
        raf = requestAnimationFrame(loop);

        setStatus("Camera started. Align subject, then tap Setup Looks Good.");
        setPill("SETUP: align subject", "rgba(0,0,0,.55)");
      }

      function switchCamera() {
        useRear = !useRear;
        startCamera().catch(err => { setStatus(err.message, true); setPill("CAM ERROR", "rgba(179,38,30,.85)"); });
      }

      async function loop() {
        if (vid.videoWidth && canvas.width !== vid.videoWidth) resizeCanvas();

        let poses = [];
        try {
          poses = await detector.estimatePoses(vid, { maxPoses: 1 });
        } catch (e) {
          setStatus("Model error. Refresh page.", true);
          setPill("MODEL ERROR", "rgba(179,38,30,.85)");
          raf = requestAnimationFrame(loop);
          return;
        }

        const pose = poses && poses[0];
        if (pose && pose.keypoints) {
          drawStick(pose.keypoints);

          if (capturing) {
            const now = performance.now();
            if (t0 === null) t0 = now;
            const t_ms = now - t0;

            frames.push({
              t_ms: Math.round(t_ms),
              w: canvas.width,
              h: canvas.height,
              keypoints: pose.keypoints.map(k => ({
                name: k.name,
                x: +k.x.toFixed(2),
                y: +k.y.toFixed(2),
                score: +(k.score ?? 0).toFixed(3)
              }))
            });

            setPill(`CAPTURING… ${frames.length}`, "rgba(179,38,30,.85)");
          } else {
            setPill(armed ? "GREEN: ready to capture" : "SETUP: align subject", armed ? "rgba(30,142,62,.85)" : "rgba(0,0,0,.55)");
          }
        } else {
          ctx.fillStyle = "#000";
          ctx.fillRect(0,0,canvas.width,canvas.height);
          setPill("No pose detected", "rgba(0,0,0,.55)");
        }

        raf = requestAnimationFrame(loop);
      }

      async function shareFile(blob, filename) {
        if (navigator.canShare && navigator.canShare({ files: [new File([blob], filename, { type: blob.type })] })) {
          const file = new File([blob], filename, { type: blob.type });
          await navigator.share({
            title: "ANVA TUG Keypoints",
            text: "Privacy-safe TUG keypoints JSON (no video saved).",
            files: [file]
          });
          return true;
        }
        return false;
      }

      function makeAndExposeJSON() {
        const ts = new Date();
        const pad = n => String(n).padStart(2,"0");
        const name = `ANVA_TUG_KEYPOINTS_${ts.getFullYear()}-${pad(ts.getMonth()+1)}-${pad(ts.getDate())}_${pad(ts.getHours())}${pad(ts.getMinutes())}.json`;

        const payload = {
          meta: {
            app: "ANVA_TUG_POSE_ONLY",
            created_local: ts.toISOString(),
            note: "No camera pixels saved. Synthetic stick figure + keypoints only.",
            tape_axis: "y",
            tape_y_norm: TAPE_Y_NORM
          },
          frames
        };

        const blob = new Blob([JSON.stringify(payload)], { type: "application/json" });
        lastJsonBlob = blob;
        lastJsonName = name;

        const url = URL.createObjectURL(blob);
        dlJson.href = url;
        dlJson.download = name;
        dlJson.textContent = `Download JSON: ${name}`;
        dlJson.style.display = "block";

        btnDrive.style.display = "block";

        detail.textContent = `Frames captured: ${frames.length}. (tape_y_norm saved as ${TAPE_Y_NORM})`;
      }

      // -------------------------
      // UI events
      // -------------------------
      btnStart.addEventListener("click", () => {
        startCamera().catch(err => { setStatus(err.message, true); setPill("CAM ERROR", "rgba(179,38,30,.85)"); });
      });

      btnSwitch.addEventListener("click", switchCamera);

      btnArm.addEventListener("click", () => {
        armed = true;
        btnGo.disabled = false;
        setPill("GREEN: ready to capture", "rgba(30,142,62,.85)");
        setStatus("Ready. Tap Start Capture.");
      });

      btnGo.addEventListener("click", async () => {
        if (!armed) return;

        capturing = true;
        btnGo.disabled = true;
        btnArm.disabled = true;
        btnStop.disabled = false;

        dlJson.style.display = "none";
        dlWebm.style.display = "none";
        btnDrive.style.display = "none";
        detail.textContent = "";

        frames = [];
        t0 = null;
        lastJsonBlob = null;
        lastJsonName = null;

        if (chkRecordStick.checked) startStickRecording();
      });

      btnStop.addEventListener("click", async () => {
        capturing = false;
        armed = false;

        btnStop.disabled = true;
        btnArm.disabled = false;
        btnGo.disabled = true;

        makeAndExposeJSON();
        setPill("DONE: save outputs", "rgba(30,142,62,.85)");
        setStatus("Stopped. Download JSON or Save to Drive.");

        if (chkRecordStick.checked) {
          const blob = await stopStickRecording();
          if (blob) {
            const ts = new Date();
            const pad = n => String(n).padStart(2,"0");
            const name = `ANVA_TUG_STICK_${ts.getFullYear()}-${pad(ts.getMonth()+1)}-${pad(ts.getDate())}_${pad(ts.getHours())}${pad(ts.getMinutes())}.webm`;
            const url = URL.createObjectURL(blob);
            dlWebm.href = url;
            dlWebm.download = name;
            dlWebm.textContent = `Download Stick Video: ${name}`;
            dlWebm.style.display = "block";
          }
        }
      });

      btnDrive.addEventListener("click", async () => {
        if (!lastJsonBlob || !lastJsonName) {
          alert("No JSON ready yet. Press Stop first.");
          return;
        }
        try {
          const ok = await shareFile(lastJsonBlob, lastJsonName);
          if (!ok) alert('Share-to-Drive not supported here. Use “Download JSON” then share from Files app.');
        } catch (e) {
          // user cancelled share; ignore
          console.log(e);
        }
      });

      // -------------------------
      // Bootstrap
      // -------------------------
      try {
        setPill("Loading libraries…");
        setStatus("Loading libraries…");
        await ensureLibraries();
        setPill("READY", "rgba(30,142,62,.85)");
        setStatus("Ready. Tap Start Camera.");
      } catch (e) {
        console.error(e);
        setPill("LOAD ERROR", "rgba(179,38,30,.85)");
        setStatus("Failed to load pose libraries. Try refreshing or switching networks.", true);
        detail.textContent = e.message;
        btnStart.disabled = true;
      }
    })();
  </script>
</body>
</html>
