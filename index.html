<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>ANVA – TUG (Skeleton + JSON)</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />

  <!-- iOS-friendly UI + tap handling -->
  <style>
    body { font-family: Arial, sans-serif; background:#f6f7f9; text-align:center; padding:16px; }
    h1 { color:#0b5ed7; margin: 8px 0 14px; }
    #wrap { width:100%; max-width:420px; margin:0 auto; }

    #stage{
      position:relative;
      width:100%;
      aspect-ratio: 9 / 16;
      border-radius:12px;
      overflow:hidden;
      background:#111;
      touch-action: none;              /* prevent scroll gestures stealing taps */
    }

    video, canvas{
      position:absolute;
      inset:0;
      width:100%;
      height:100%;
      object-fit: cover;
    }

    /* Blue tape overlay (tap this) */
    #tape{
      position:absolute;
      left:0;
      width:100%;
      height:10px;
      background:#1677ff;
      opacity:0.9;
      top:72%;                         /* initial visual position; will be updated by drag later if you want */
      z-index:5;
      cursor:pointer;
      touch-action: manipulation;
    }

    #hint{
      position:absolute;
      left:0;
      width:100%;
      top:58%;
      z-index:6;
      color:#fff;
      font-size:14px;
      text-shadow: 0 1px 2px rgba(0,0,0,0.6);
      pointer-events:none;
      padding: 0 8px;
      box-sizing:border-box;
    }

    #panel{ margin-top:12px; }
    button{
      font-size:18px;
      padding:12px 18px;
      border-radius:10px;
      border:none;
      cursor:pointer;
      margin:8px 6px;
      touch-action: manipulation;
    }
    #startBtn{ background:#0b5ed7; color:#fff; width: 70%; max-width:320px; }
    #recordBtn{ background:#198754; color:#fff; width: 45%; max-width:190px; }
    #stopBtn{ background:#dc3545; color:#fff; width: 45%; max-width:190px; opacity:0.6; }

    #statusBar{
      margin:10px auto 0;
      width: 100%;
      max-width:420px;
      background:#e9ecef;
      border-radius:12px;
      padding:10px 12px;
      box-sizing:border-box;
      display:flex;
      gap:10px;
      justify-content:space-between;
      flex-wrap:wrap;
      font-size:14px;
      color:#222;
    }
    .pill{
      background:#fff;
      padding:6px 10px;
      border-radius:999px;
      border:1px solid #d6d8db;
    }

    #modeBanner{
      margin:12px auto 10px;
      width:100%;
      max-width:420px;
      background:#0f7a3a;
      color:#fff;
      border-radius:12px;
      padding:10px 12px;
      box-sizing:border-box;
      font-size:18px;
      display:flex;
      align-items:center;
      justify-content:center;
      gap:10px;
    }
    #dot{
      width:16px;height:16px;border-radius:50%;
      background:#2dff6a;
      box-shadow:0 0 10px rgba(45,255,106,0.7);
    }

    /* IMPORTANT: ensure buttons are above anything */
    #panel, #modeBanner, #statusBar { position:relative; z-index:10; }
  </style>

  <!-- TensorFlow.js + Pose Detection (MoveNet) -->
  <script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs-core@4.20.0/dist/tf-core.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs-converter@4.20.0/dist/tf-converter.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs-backend-webgl@4.20.0/dist/tf-backend-webgl.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/@tensorflow-models/pose-detection@2.1.3/dist/pose-detection.min.js"></script>
</head>

<body>
  <div id="wrap">
    <h1>ANVA – TUG</h1>

    <div id="stage">
      <video id="video" playsinline muted></video>
      <canvas id="canvas"></canvas>

      <div id="tape" aria-label="Blue tape (tap to toggle skeleton mode)"></div>
      <div id="hint">Tap the blue tape to switch to Skeleton Mode</div>
    </div>

    <div id="modeBanner">
      <div id="dot"></div>
      <div id="bannerText">Camera Mode — tap tape for Skeleton</div>
    </div>

    <div id="panel">
      <button id="startBtn" type="button">Start Camera</button><br/>
      <button id="recordBtn" type="button" disabled>Record (JSON)</button>
      <button id="stopBtn" type="button" disabled>Stop</button>

      <div id="statusBar">
        <div class="pill" id="modePill">Mode: Camera</div>
        <div class="pill" id="framesPill">Frames: 0</div>
        <div class="pill" id="fpsPill">FPS: —</div>
        <div class="pill" id="tapePill">Tape y_norm: —</div>
      </div>
    </div>
  </div>

<script>
(() => {
  // ---------- Elements ----------
  const video    = document.getElementById('video');
  const canvas   = document.getElementById('canvas');
  const ctx      = canvas.getContext('2d');

  const stage    = document.getElementById('stage');
  const tapeEl   = document.getElementById('tape');

  const startBtn = document.getElementById('startBtn');
  const recordBtn= document.getElementById('recordBtn');
  const stopBtn  = document.getElementById('stopBtn');

  const modePill = document.getElementById('modePill');
  const framesPill = document.getElementById('framesPill');
  const fpsPill  = document.getElementById('fpsPill');
  const tapePill = document.getElementById('tapePill');

  const bannerText = document.getElementById('bannerText');
  const hintEl = document.getElementById('hint');

  // ---------- State ----------
  let stream = null;
  let detector = null;
  let rafId = null;

  let skeletonMode = false;     // false = normal camera, true = draw skeleton
  let isRecording = false;
  let frames = [];
  let t0 = 0;

  let lastFrameTs = performance.now();
  let fps = 0;

  // tape position (computed from DOM each frame so it's always correct)
  let tapeYNorm = null;   // 0..1 in stage space

  // ---------- Helpers ----------
  function setButtons(cameraOn){
    recordBtn.disabled = !cameraOn;
    // stop only enabled while recording
    stopBtn.disabled = !isRecording;
    stopBtn.style.opacity = isRecording ? 1 : 0.6;
  }

  function setUIRecording(on){
    isRecording = on;
    recordBtn.disabled = on;      // lock record while recording
    stopBtn.disabled = !on;
    stopBtn.style.opacity = on ? 1 : 0.6;
  }

  function setUIMode(){
    modePill.textContent = `Mode: ${skeletonMode ? 'Skeleton' : 'Camera'}`;
    bannerText.textContent = skeletonMode
      ? 'Skeleton Mode — press Record (JSON)'
      : 'Camera Mode — tap tape for Skeleton';
    hintEl.style.display = skeletonMode ? 'none' : 'block';
  }

  function resizeCanvasToVideo(){
    const w = video.videoWidth || 0;
    const h = video.videoHeight || 0;
    if (!w || !h) return;

    if (canvas.width !== w)  canvas.width = w;
    if (canvas.height !== h) canvas.height = h;
  }

  // Stage-space normalized tape Y (0..1), measured from DOM
  function updateTapeYNormFromDOM(){
    const stageRect = stage.getBoundingClientRect();
    const tapeRect  = tapeEl.getBoundingClientRect();

    const tapeCenterY = (tapeRect.top + tapeRect.bottom) / 2;
    const y = (tapeCenterY - stageRect.top) / stageRect.height;
    tapeYNorm = Math.max(0, Math.min(1, y));
    tapePill.textContent = `Tape y_norm: ${tapeYNorm.toFixed(2)}`;
  }

  function downloadJSON(payloadObj){
    const blob = new Blob([JSON.stringify(payloadObj)], { type: "application/json" });
    const url  = URL.createObjectURL(blob);

    const a = document.createElement('a');
    a.href = url;
    a.download = `anva_tug_${new Date().toISOString().replace(/[:.]/g,'-')}.json`;
    document.body.appendChild(a);
    a.click();
    a.remove();

    setTimeout(() => URL.revokeObjectURL(url), 1500);
  }

  // ---------- Drawing ----------
  // Minimal skeleton edges for MoveNet (17 keypoints)
  const EDGES = [
    [5,7],[7,9],     // left arm
    [6,8],[8,10],    // right arm
    [5,6],           // shoulders
    [5,11],[6,12],   // torso
    [11,12],         // hips
    [11,13],[13,15], // left leg
    [12,14],[14,16], // right leg
  ];

  function drawSkeleton(keypoints){
    ctx.clearRect(0,0,canvas.width, canvas.height);

    // Draw tape guide line in canvas coordinates (for debugging / trust)
    if (tapeYNorm != null){
      const y = tapeYNorm * canvas.height;
      ctx.beginPath();
      ctx.moveTo(0, y);
      ctx.lineTo(canvas.width, y);
      ctx.lineWidth = 4;
      ctx.strokeStyle = "#1677ff";
      ctx.stroke();
    }

    // points
    for (const kp of keypoints){
      if (!kp || kp.score < 0.25) continue;
      ctx.beginPath();
      ctx.arc(kp.x, kp.y, 4, 0, Math.PI*2);
      ctx.fillStyle = "#00ff7a";
      ctx.fill();
    }

    // edges
    ctx.lineWidth = 3;
    ctx.strokeStyle = "#00ff7a";
    for (const [a,b] of EDGES){
      const ka = keypoints[a], kb = keypoints[b];
      if (!ka || !kb) continue;
      if (ka.score < 0.25 || kb.score < 0.25) continue;
      ctx.beginPath();
      ctx.moveTo(ka.x, ka.y);
      ctx.lineTo(kb.x, kb.y);
      ctx.stroke();
    }
  }

  // ---------- Main Loop ----------
  async function loop(){
    try{
      // update DOM-measured tape Y each frame (this is the fix you wanted)
      updateTapeYNormFromDOM();

      // FPS calc
      const now = performance.now();
      const dt = now - lastFrameTs;
      lastFrameTs = now;
      if (dt > 0) fps = 1000 / dt;
      fpsPill.textContent = `FPS: ${fps.toFixed(0)}`;

      // ensure canvas matches video pixel space
      resizeCanvasToVideo();

      if (!detector || video.readyState < 2){
        rafId = requestAnimationFrame(loop);
        return;
      }

      // Pose estimation
      const poses = await detector.estimatePoses(video, { flipHorizontal: true });
      const pose = poses && poses[0] ? poses[0] : null;

      if (pose && pose.keypoints && pose.keypoints.length){
        if (skeletonMode){
          drawSkeleton(pose.keypoints);
        } else {
          // privacy-first: no drawing in camera mode (video is live preview only)
          ctx.clearRect(0,0,canvas.width, canvas.height);
        }

        // RECORD JSON FRAMES (THIS is what was missing in your current behavior)
        if (isRecording){
          const kps = pose.keypoints.map(k => ({
            // normalize to video pixel space for replay
            x: +(k.x / canvas.width).toFixed(5),
            y: +(k.y / canvas.height).toFixed(5),
            s: +(+k.score).toFixed(5)
          }));

          frames.push({
            t_ms: Math.round(performance.now() - t0),
            tape_y_norm: tapeYNorm == null ? null : +tapeYNorm.toFixed(5),
            kps
          });

          framesPill.textContent = `Frames: ${frames.length}`;
        }
      } else {
        if (!skeletonMode) ctx.clearRect(0,0,canvas.width, canvas.height);
      }

      rafId = requestAnimationFrame(loop);
    } catch (err){
      console.error(err);
      rafId = requestAnimationFrame(loop);
    }
  }

  // ---------- Init TFJS + MoveNet ----------
  async function initDetector(){
    await tf.setBackend('webgl');
    await tf.ready();

    const model = poseDetection.SupportedModels.MoveNet;
    const detectorConfig = {
      modelType: poseDetection.movenet.modelType.SINGLEPOSE_LIGHTNING
    };
    detector = await poseDetection.createDetector(model, detectorConfig);
  }

  // ---------- Camera ----------
  async function startCamera(){
    if (stream) return;

    // request environment camera if available
    stream = await navigator.mediaDevices.getUserMedia({
      audio:false,
      video:{
        facingMode: { ideal: "environment" },
        width: { ideal: 720 },
        height: { ideal: 1280 }
      }
    });

    video.srcObject = stream;

    // iOS: must play after user gesture
    await video.play();

    await initDetector();

    setButtons(true);
    setUIMode();
    framesPill.textContent = "Frames: 0";
    fpsPill.textContent = "FPS: —";

    cancelAnimationFrame(rafId);
    rafId = requestAnimationFrame(loop);
  }

  // ---------- Events (iPhone-proof: pointerup) ----------
  startBtn.addEventListener('pointerup', async (e) => {
    e.preventDefault(); e.stopPropagation();
    try{
      startBtn.disabled = true;
      await startCamera();
    } catch(err){
      console.error(err);
      alert("Camera start failed. Check permissions and reload.");
      startBtn.disabled = false;
    }
  });

  // Tap tape toggles skeleton mode (exactly your UX)
  tapeEl.addEventListener('pointerup', (e) => {
    e.preventDefault(); e.stopPropagation();
    skeletonMode = !skeletonMode;
    setUIMode();
  });

  recordBtn.addEventListener('pointerup', (e) => {
    e.preventDefault(); e.stopPropagation();
    if (!detector) return;

    frames = [];
    t0 = performance.now();
    framesPill.textContent = "Frames: 0";
    setUIRecording(true);
  });

  stopBtn.addEventListener('pointerup', (e) => {
    e.preventDefault(); e.stopPropagation();
    if (!isRecording) return;

    setUIRecording(false);

    // IMPORTANT: iOS download must happen directly in this user gesture
    const payload = {
      version: "anva_tug_json_v1",
      device: navigator.userAgent,
      started_epoch_ms: Date.now(),
      frames
    };

    downloadJSON(payload);
  });

  // Initial UI
  setUIMode();
  setButtons(false);

})();
</script>
</body>
</html>
