<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, viewport-fit=cover" />
  <title>ANVA — TUG Privacy (Stick Figure + Drive Share)</title>
  <style>
    :root{ --brand:#0b5ed7; --ok:#1e8e3e; --warn:#b3261e; --bg:#f6f7f9; --card:#fff; --muted:#6b7280; }
    body{ margin:0; font-family:system-ui,-apple-system,Segoe UI,Roboto,Arial,sans-serif; background:var(--bg); padding:14px; color:#111827; text-align:center;}
    h1{ margin:6px 0 10px; font-size:18px; color:var(--brand); }
    .card{ max-width:520px; margin:0 auto; background:var(--card); border-radius:14px; padding:12px; box-shadow:0 6px 22px rgba(0,0,0,.06);}
    .hint{ font-size:13px; color:var(--muted); text-align:left; line-height:1.35; margin:8px 0 10px;}
    .row{ display:flex; gap:10px; justify-content:center; flex-wrap:wrap; margin-top:10px;}
    button{ border:0; border-radius:12px; padding:12px 14px; font-size:14px; font-weight:700; cursor:pointer; background:var(--brand); color:#fff; min-width:150px;}
    button.secondary{ background:#111827; }
    button.good{ background:var(--ok); }
    button.danger{ background:var(--warn); }
    button:disabled{ opacity:.45; cursor:not-allowed; }
    #stage{ position:relative; width:100%; max-width:480px; margin:10px auto 0; border-radius:14px; overflow:hidden; background:#000; display:none;}
    video{ width:100%; height:auto; display:block; }
    canvas{ width:100%; height:auto; display:block; background:#000; }
    #pill{ position:absolute; left:10px; top:10px; padding:6px 10px; border-radius:999px; font-size:12px; color:#fff; background:rgba(0,0,0,.55); }
    .tog{ display:flex; justify-content:space-between; align-items:center; gap:10px; margin-top:10px; font-size:13px; color:var(--muted); text-align:left;}
    input[type="checkbox"]{ transform:scale(1.2); }
    a.dl{ display:none; margin-top:12px; font-weight:800; color:var(--brand); text-decoration:none; word-break:break-word; }
    pre{ text-align:left; font-size:12px; color:#111827; background:#f3f4f6; padding:10px; border-radius:12px; overflow:auto; display:none; }
    .full{ width:100%; max-width:520px; }
  </style>
</head>
<body>
  <h1>ANVA — TUG (Privacy Special)</h1>

  <div class="card">
    <div class="hint">
      <b>Privacy:</b> No camera video is saved. Outputs are <b>synthetic stick figure</b> + <b>keypoints JSON</b> only.<br/>
      <b>Setup:</b> Frontal view. Keep body below neck + feet + blue tape visible.
    </div>

    <div class="row">
      <button id="btnStart">Start Camera</button>
      <button id="btnSwitch" class="secondary" disabled>Switch Camera</button>
    </div>

    <div id="stage">
      <video id="vid" playsinline muted></video>
      <div id="pill">Loading model…</div>
      <canvas id="viz"></canvas>
    </div>

    <div class="tog">
      <label><input id="chkShowVideo" type="checkbox" /> Show live video under stick figure (preview only)</label>
    </div>
    <div class="tog">
      <label><input id="chkRecordStick" type="checkbox" checked /> Record stick figure (no pixels) as WebM</label>
    </div>

    <div class="row">
      <button id="btnArm" class="good" disabled>Setup Looks Good</button>
      <button id="btnGo" class="danger" disabled>Start Capture</button>
      <button id="btnStop" class="secondary" disabled>Stop</button>
    </div>

    <a id="dlJson" class="dl" download>Download keypoints JSON</a>

    <button id="btnDrive" class="good full" style="display:none; margin-top:10px;">
      Save keypoints to Google Drive
    </button>

    <a id="dlWebm" class="dl" download>Download stick-figure video</a>
    <pre id="debug"></pre>
  </div>

  <!-- TFJS + Pose Detection -->
  <script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs@4.17.0/dist/tf.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/@tensorflow-models/pose-detection@2.1.3/dist/pose-detection.min.js"></script>

  <script>
  (async () => {
    const btnStart  = document.getElementById('btnStart');
    const btnSwitch = document.getElementById('btnSwitch');
    const btnArm    = document.getElementById('btnArm');
    const btnGo     = document.getElementById('btnGo');
    const btnStop   = document.getElementById('btnStop');

    const vid = document.getElementById('vid');
    const stage = document.getElementById('stage');
    const pill = document.getElementById('pill');
    const canvas = document.getElementById('viz');
    const ctx = canvas.getContext('2d');

    const chkShowVideo = document.getElementById('chkShowVideo');
    const chkRecordStick = document.getElementById('chkRecordStick');

    const dlJson = document.getElementById('dlJson');
    const dlWebm = document.getElementById('dlWebm');
    const btnDrive = document.getElementById('btnDrive');
    const debug = document.getElementById('debug');

    let stream = null;
    let useRear = true;
    let detector = null;

    let raf = null;
    let capturing = false;
    let armed = false;

    // Stored results (privacy-safe)
    let frames = []; // each: {t_ms, keypoints:[{name,x,y,score}], w,h}
    let t0 = null;

    // Optional stick-figure-only video recording (canvas stream)
    let rec = null;
    let recChunks = [];

    // Share state
    let lastJsonBlob = null;
    let lastJsonName = null;

    function setPill(text, bg='rgba(0,0,0,.55)'){ pill.textContent=text; pill.style.background=bg; }

    async function loadModel() {
      setPill('Loading MoveNet…');
      await tf.ready();
      try { await tf.setBackend('webgl'); } catch(e) {}
      const model = poseDetection.SupportedModels.MoveNet;
      const cfg = {
        modelType: poseDetection.movenet.modelType.SINGLEPOSE_LIGHTNING,
        enableSmoothing: true
      };
      detector = await poseDetection.createDetector(model, cfg);
      setPill('Model ready', 'rgba(30,142,62,.85)');
    }

    async function startCamera() {
      // Stop old stream
      if (stream) { stream.getTracks().forEach(t => t.stop()); stream=null; }

      // Reset UI states
      dlJson.style.display = 'none';
      dlWebm.style.display = 'none';
      btnDrive.style.display = 'none';
      debug.style.display = 'none';

      frames = [];
      t0 = null;
      armed = false;
      capturing = false;
      lastJsonBlob = null;
      lastJsonName = null;

      const constraints = {
        audio: false,
        video: {
          facingMode: useRear ? { ideal: "environment" } : { ideal: "user" },
          width: { ideal: 1280 },
          height: { ideal: 720 }
        }
      };

      stream = await navigator.mediaDevices.getUserMedia(constraints);
      vid.srcObject = stream;
      await vid.play();

      stage.style.display = 'block';
      btnSwitch.disabled = false;
      btnArm.disabled = false;
      btnGo.disabled = true;
      btnStop.disabled = true;

      setPill('SETUP: align body below neck + feet + tape', 'rgba(0,0,0,.55)');

      resizeCanvas();
      if (!detector) await loadModel();

      if (raf) cancelAnimationFrame(raf);
      raf = requestAnimationFrame(loop);
    }

    function resizeCanvas() {
      const vw = vid.videoWidth || 1280;
      const vh = vid.videoHeight || 720;
      canvas.width = vw;
      canvas.height = vh;
    }

    function switchCamera() {
      useRear = !useRear;
      startCamera().catch(err => alert('Camera error: ' + err.message));
    }

    // Draw skeleton using MoveNet keypoint names
    const EDGES = [
      ['nose','left_eye'],['nose','right_eye'],['left_eye','left_ear'],['right_eye','right_ear'],
      ['left_shoulder','right_shoulder'],
      ['left_shoulder','left_elbow'],['left_elbow','left_wrist'],
      ['right_shoulder','right_elbow'],['right_elbow','right_wrist'],
      ['left_shoulder','left_hip'],['right_shoulder','right_hip'],
      ['left_hip','right_hip'],
      ['left_hip','left_knee'],['left_knee','left_ankle'],
      ['right_hip','right_knee'],['right_knee','right_ankle']
    ];

    function kpMap(keypoints) {
      const m = new Map();
      for (const k of keypoints) m.set(k.name, k);
      return m;
    }

    function drawStick(keypoints) {
      const m = kpMap(keypoints);

      // Clear
      ctx.clearRect(0,0,canvas.width,canvas.height);

      // Optional preview video UNDER skeleton (still not saved)
      if (chkShowVideo.checked) {
        ctx.globalAlpha = 0.30;
        ctx.drawImage(vid, 0, 0, canvas.width, canvas.height);
        ctx.globalAlpha = 1.0;
      }

      // Dark background to emphasize privacy
      if (!chkShowVideo.checked) {
        ctx.fillStyle = '#000';
        ctx.fillRect(0,0,canvas.width,canvas.height);
      }

      // Visual tape guides (safe: synthetic overlay)
      ctx.save();
      ctx.strokeStyle = 'rgba(0,140,255,0.75)';
      ctx.lineWidth = Math.max(3, Math.floor(canvas.width * 0.004));
      ctx.beginPath();
      ctx.moveTo(canvas.width*0.08, canvas.height*0.70);
      ctx.lineTo(canvas.width*0.92, canvas.height*0.70);
      ctx.stroke();
      ctx.beginPath();
      ctx.moveTo(canvas.width*0.08, canvas.height*0.40);
      ctx.lineTo(canvas.width*0.92, canvas.height*0.40);
      ctx.stroke();
      ctx.restore();

      // Edges
      ctx.save();
      ctx.strokeStyle = 'rgba(255,255,255,0.9)';
      ctx.lineWidth = Math.max(4, Math.floor(canvas.width * 0.006));
      for (const [a,b] of EDGES) {
        const A = m.get(a), B = m.get(b);
        if (!A || !B) continue;
        if ((A.score ?? 0) < 0.2 || (B.score ?? 0) < 0.2) continue;
        ctx.beginPath();
        ctx.moveTo(A.x, A.y);
        ctx.lineTo(B.x, B.y);
        ctx.stroke();
      }
      ctx.restore();

      // Joints (no pixels, only synthetic circles)
      ctx.save();
      ctx.fillStyle = 'rgba(255,255,255,0.95)';
      const r = Math.max(3, Math.floor(canvas.width * 0.006));
      for (const k of keypoints) {
        if ((k.score ?? 0) < 0.2) continue;
        ctx.beginPath();
        ctx.arc(k.x, k.y, r, 0, Math.PI*2);
        ctx.fill();
      }
      ctx.restore();
    }

    function startStickRecording() {
      recChunks = [];
      const cs = canvas.captureStream(30);
      const mimeTypes = ['video/webm;codecs=vp9','video/webm;codecs=vp8','video/webm'];
      let chosen = '';
      for (const mt of mimeTypes) if (MediaRecorder.isTypeSupported(mt)) { chosen = mt; break; }
      rec = new MediaRecorder(cs, chosen ? { mimeType: chosen } : {});
      rec.ondataavailable = (e) => { if (e.data && e.data.size > 0) recChunks.push(e.data); };
      rec.start(250);
    }

    function stopStickRecording() {
      return new Promise((resolve) => {
        if (!rec || rec.state === 'inactive') return resolve(null);
        rec.onstop = () => {
          const blob = new Blob(recChunks, { type: rec.mimeType || 'video/webm' });
          resolve(blob);
        };
        rec.stop();
      });
    }

    async function loop() {
      if (canvas.width !== (vid.videoWidth||0) && (vid.videoWidth||0)>0) resizeCanvas();

      let poses = [];
      try {
        poses = await detector.estimatePoses(vid, { maxPoses: 1, flipHorizontal: false });
      } catch (e) {
        setPill('Model error (refresh page)', 'rgba(179,38,30,.85)');
        raf = requestAnimationFrame(loop);
        return;
      }

      const pose = poses && poses[0];
      if (pose && pose.keypoints) {
        drawStick(pose.keypoints);

        if (capturing) {
          const now = performance.now();
          if (t0 === null) t0 = now;
          const t_ms = now - t0;

          frames.push({
            t_ms: Math.round(t_ms),
            w: canvas.width,
            h: canvas.height,
            keypoints: pose.keypoints.map(k => ({
              name: k.name,
              x: +k.x.toFixed(2),
              y: +k.y.toFixed(2),
              score: +(k.score ?? 0).toFixed(3)
            }))
          });

          setPill(`CAPTURING… ${frames.length} frames`, 'rgba(179,38,30,.85)');
        } else {
          setPill(armed ? 'GREEN: ready to capture' : 'SETUP: align body + feet + tape',
                  armed ? 'rgba(30,142,62,.85)' : 'rgba(0,0,0,.55)');
        }
      } else {
        ctx.clearRect(0,0,canvas.width,canvas.height);
        ctx.fillStyle = '#000'; ctx.fillRect(0,0,canvas.width,canvas.height);
        setPill('No pose detected — adjust framing', 'rgba(0,0,0,.55)');
      }

      raf = requestAnimationFrame(loop);
    }

    async function shareFile(blob, filename) {
      if (navigator.canShare && navigator.canShare({ files: [new File([blob], filename, { type: blob.type })] })) {
        const file = new File([blob], filename, { type: blob.type });
        await navigator.share({
          title: 'ANVA TUG Keypoints',
          text: 'ANVA TUG privacy-safe keypoints JSON (no video pixels saved).',
          files: [file]
        });
        return true;
      }
      return false;
    }

    function makeAndExposeJSON() {
      const ts = new Date();
      const pad = n => String(n).padStart(2,'0');
      const name = `ANVA_TUG_KEYPOINTS_${ts.getFullYear()}-${pad(ts.getMonth()+1)}-${pad(ts.getDate())}_${pad(ts.getHours())}${pad(ts.getMinutes())}.json`;

      const payload = {
        meta: {
          app: "ANVA_TUG_PRIVACY_STICK",
          created_local: ts.toISOString(),
          note: "No camera pixels saved. Synthetic stick figure + keypoints only."
        },
        frames
      };

      const blob = new Blob([JSON.stringify(payload)], { type: 'application/json' });
      lastJsonBlob = blob;
      lastJsonName = name;

      // Download link fallback
      const url = URL.createObjectURL(blob);
      dlJson.href = url;
      dlJson.download = name;
      dlJson.textContent = `Download JSON: ${name}`;
      dlJson.style.display = 'block';

      // Drive share button (share sheet)
      btnDrive.style.display = 'block';

      // Optional debug
      debug.style.display = 'block';
      debug.textContent = `Frames: ${frames.length}\nFirst t_ms: ${frames[0]?.t_ms ?? 'n/a'}\nLast t_ms: ${frames[frames.length-1]?.t_ms ?? 'n/a'}`;
    }

    // UI hooks
    btnStart.addEventListener('click', () => startCamera().catch(err => alert('Camera error: ' + err.message)));
    btnSwitch.addEventListener('click', switchCamera);

    btnArm.addEventListener('click', () => {
      armed = true;
      btnGo.disabled = false;
      setPill('GREEN: ready to capture', 'rgba(30,142,62,.85)');
    });

    btnGo.addEventListener('click', async () => {
      if (!armed) return;

      capturing = true;
      btnGo.disabled = true;
      btnArm.disabled = true;
      btnStop.disabled = false;

      dlJson.style.display = 'none';
      dlWebm.style.display = 'none';
      btnDrive.style.display = 'none';
      debug.style.display = 'none';

      frames = [];
      t0 = null;
      lastJsonBlob = null;
      lastJsonName = null;

      if (chkRecordStick.checked) startStickRecording();
    });

    btnStop.addEventListener('click', async () => {
      capturing = false;
      armed = false;

      btnStop.disabled = true;
      btnArm.disabled = false;
      btnGo.disabled = true;

      makeAndExposeJSON();
      setPill('DONE: download or save to Drive', 'rgba(30,142,62,.85)');

      if (chkRecordStick.checked) {
        const blob = await stopStickRecording();
        if (blob) {
          const ts = new Date();
          const pad = n => String(n).padStart(2,'0');
          const name = `ANVA_TUG_STICK_${ts.getFullYear()}-${pad(ts.getMonth()+1)}-${pad(ts.getDate())}_${pad(ts.getHours())}${pad(ts.getMinutes())}.webm`;
          const url = URL.createObjectURL(blob);
          dlWebm.href = url;
          dlWebm.download = name;
          dlWebm.textContent = `Download Stick Video: ${name}`;
          dlWebm.style.display = 'block';
        }
      }
    });

    btnDrive.addEventListener('click', async () => {
      if (!lastJsonBlob || !lastJsonName) {
        alert('No JSON ready yet. Press Stop first.');
        return;
      }
      try {
        const ok = await shareFile(lastJsonBlob, lastJsonName);
        if (!ok) {
          alert('Share-to-Drive not supported on this browser. Use “Download JSON” then share from Files app.');
        }
      } catch (e) {
        // User can cancel share sheet; not an error.
        console.log(e);
      }
    });

  })();
  </script>
</body>
</html>
