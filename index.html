<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, viewport-fit=cover" />
  <title>ANVA — TUG (Pose Only)</title>

  <style>
    :root { --brand:#0b5ed7; --ok:#16a34a; --warn:#b45309; --danger:#ef4444; --bg:#f6f7f9; --card:#fff; }
    body { margin:0; font-family: Arial, sans-serif; background:var(--bg); text-align:center; padding:16px; }
    h1 { color:var(--brand); margin:10px 0 6px; letter-spacing:1px; }
    .sub { color:#4b5563; font-size:14px; margin:0 0 12px; }
    .card { max-width:420px; margin:0 auto; background:var(--card); border-radius:16px; padding:14px; box-shadow:0 10px 28px rgba(0,0,0,.08); }
    #stage { position:relative; width:100%; aspect-ratio:9/16; background:#000; border-radius:14px; overflow:hidden; }
    video { position:absolute; inset:0; width:100%; height:100%; object-fit:cover; display:none; }
    canvas { position:absolute; inset:0; width:100%; height:100%; }
    #badge { position:absolute; top:10px; left:10px; padding:8px 10px; border-radius:999px; font-weight:800; font-size:12px; color:#fff; background:#374151; }
    .row { display:flex; gap:10px; justify-content:center; flex-wrap:wrap; margin:12px 0 6px; }
    button { border:none; border-radius:12px; padding:14px 14px; font-size:16px; font-weight:800; min-width:120px; cursor:pointer; }
    button:disabled { opacity:.45; cursor:not-allowed; }
    #btnCamera { background:var(--brand); color:#fff; }
    #btnTape { background:#10b981; color:#052e24; }
    #btnStart { background:#86efac; color:#052e24; }
    #btnStop { background:#fecaca; color:#450a0a; }
    .small { font-size:13px; color:#111827; margin:10px 0 0; line-height:1.35; }
    .small b { font-weight:900; }
    .toggle { display:flex; align-items:center; justify-content:center; gap:8px; margin:8px 0 0; font-size:14px; color:#374151; }
    #status { margin:10px 0 0; font-weight:800; color:#065f46; min-height:22px; }
    code { background:#eef2ff; padding:2px 6px; border-radius:6px; }
  </style>

  <!-- TensorFlow.js + MoveNet -->
  <script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs@4.20.0/dist/tf.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/@tensorflow-models/pose-detection@2.1.3/dist/pose-detection.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/@tensorflow-models/pose-detection@2.1.3/dist/pose-detection.min.js.map"></script>
</head>

<body>
  <h1>ANVA — TUG (Pose Only)</h1>
  <p class="sub">Privacy mode: Camera used only to extract pose. No video/images are saved.</p>

  <div class="card">
    <div class="small">
      <b>Privacy mode:</b> Camera is used only to extract pose.<br/>
      <b>No video/images</b> are ever saved.
    </div>

    <div id="stage">
      <div id="badge">LOAD</div>
      <video id="video" playsinline muted></video>
      <canvas id="canvas"></canvas>
    </div>

    <label class="toggle">
      <input id="showVideo" type="checkbox" />
      Show live video under stick figure (preview only)
    </label>

    <div class="row">
      <button id="btnCamera">Start Camera</button>
      <button id="btnTape" disabled>Set Tape</button>
    </div>
    <div class="row">
      <button id="btnStart" disabled>Start TUG</button>
      <button id="btnStop" disabled>Stop</button>
    </div>

    <div id="status">Loading libraries…</div>
    <div class="small" style="margin-top:8px;">
      Workflow: <b>Start Camera</b> → <b>Set Tape</b> (tap on tape) → <b>Start TUG</b> → <b>Stop</b> → JSON downloads
    </div>
  </div>

<script>
(() => {
  const video = document.getElementById('video');
  const canvas = document.getElementById('canvas');
  const ctx = canvas.getContext('2d');

  const badge = document.getElementById('badge');
  const statusEl = document.getElementById('status');

  const btnCamera = document.getElementById('btnCamera');
  const btnTape = document.getElementById('btnTape');
  const btnStart = document.getElementById('btnStart');
  const btnStop  = document.getElementById('btnStop');
  const showVideo = document.getElementById('showVideo');

  // --- State ---
  let detector = null;
  let stream = null;
  let rafId = null;

  let tapeYNorm = null;      // saved into JSON meta
  let tapeArmed = false;     // when true, next tap sets tape
  let tugRecording = false;  // when true, we store frames
  let frames = [];           // keypoints-only frames
  let startEpochMs = null;

  // --- Config ---
  const MODEL = poseDetection.SupportedModels.MoveNet;
  const modelConfig = { modelType: poseDetection.movenet.modelType.SINGLEPOSE_LIGHTNING };

  // For gating: require a few consecutive frames with decent hip/ankle scores
  let stableCount = 0;
  const STABLE_NEED = 10;
  const MIN_SCORE = 0.25;

  function setBadge(text, color){
    badge.textContent = text;
    badge.style.background = color || '#374151';
  }

  function setStatus(text, color){
    statusEl.textContent = text;
    statusEl.style.color = color || '#065f46';
  }

  function resizeCanvas(){
    const rect = canvas.getBoundingClientRect();
    canvas.width  = Math.floor(rect.width  * devicePixelRatio);
    canvas.height = Math.floor(rect.height * devicePixelRatio);
    ctx.setTransform(devicePixelRatio,0,0,devicePixelRatio,0,0);
  }

  function nowIsoCompact(){
    const d = new Date();
    const pad = n => String(n).padStart(2,'0');
    return `${d.getFullYear()}-${pad(d.getMonth()+1)}-${pad(d.getDate())}_${pad(d.getHours())}${pad(d.getMinutes())}`;
  }

  function keypointsToNamed(kps){
    // MoveNet returns 17 points with .name sometimes absent; map by index fallback
    const names = [
      "nose","left_eye","right_eye","left_ear","right_ear",
      "left_shoulder","right_shoulder","left_elbow","right_elbow",
      "left_wrist","right_wrist","left_hip","right_hip",
      "left_knee","right_knee","left_ankle","right_ankle"
    ];
    return kps.map((k,i) => ({
      name: k.name || names[i] || `kp_${i}`,
      x: k.x,
      y: k.y,
      score: (k.score ?? 0)
    }));
  }

  function drawStickFigure(kps){
    // Clear
    ctx.clearRect(0,0,canvas.width,canvas.height);

    // If live video preview enabled, show it underneath (not saved)
    if(showVideo.checked){
      // draw video into canvas background
      ctx.save();
      ctx.globalAlpha = 1.0;
      ctx.drawImage(video, 0, 0, canvas.width/devicePixelRatio, canvas.height/devicePixelRatio);
      ctx.restore();
    }

    // draw joints + simple skeleton
    const w = canvas.width/devicePixelRatio, h = canvas.height/devicePixelRatio;

    const byName = {};
    for(const p of kps){ byName[p.name] = p; }

    const P = n => byName[n] ? [byName[n].x, byName[n].y, byName[n].score] : null;

    const segs = [
      ["left_shoulder","right_shoulder"],
      ["left_shoulder","left_elbow"],
      ["left_elbow","left_wrist"],
      ["right_shoulder","right_elbow"],
      ["right_elbow","right_wrist"],
      ["left_shoulder","left_hip"],
      ["right_shoulder","right_hip"],
      ["left_hip","right_hip"],
      ["left_hip","left_knee"],
      ["left_knee","left_ankle"],
      ["right_hip","right_knee"],
      ["right_knee","right_ankle"],
    ];

    // lines
    ctx.lineWidth = 3;
    ctx.strokeStyle = "rgba(0,255,140,0.9)";
    for(const [a,b] of segs){
      const A = P(a), B = P(b);
      if(!A || !B) continue;
      if(A[2] < MIN_SCORE || B[2] < MIN_SCORE) continue;
      ctx.beginPath();
      ctx.moveTo(A[0]*w, A[1]*h);
      ctx.lineTo(B[0]*w, B[1]*h);
      ctx.stroke();
    }

    // points
    ctx.fillStyle = "rgba(0,255,140,0.9)";
    for(const p of kps){
      if((p.score ?? 0) < MIN_SCORE) continue;
      ctx.beginPath();
      ctx.arc(p.x*w, p.y*h, 4, 0, Math.PI*2);
      ctx.fill();
    }

    // NOTE: no tape line drawn (your requirement)
  }

  function isStablePose(kps){
    const need = ["left_hip","right_hip","left_ankle","right_ankle"];
    const byName = {};
    for(const p of kps) byName[p.name]=p;
    for(const n of need){
      if(!byName[n]) return false;
      if((byName[n].score ?? 0) < MIN_SCORE) return false;
    }
    return true;
  }

  async function initDetector(){
    await tf.setBackend('webgl').catch(()=>{});
    await tf.ready();
    detector = await poseDetection.createDetector(MODEL, modelConfig);
  }

  async function startCamera(){
    if(stream) return;
    resizeCanvas();

    stream = await navigator.mediaDevices.getUserMedia({
      audio:false,
      video:{
        facingMode:"user",
        width:{ ideal: 720 },
        height:{ ideal: 1280 }
      }
    });

    video.srcObject = stream;
    await video.play();

    // If preview enabled, we still never save pixels.
    setBadge("CAM", "#111827");
    setStatus("Camera started. Now tap Set Tape, then tap on the floor tape.", "#065f46");

    btnTape.disabled = false;
    btnStop.disabled = false;

    loop();
  }

  async function loop(){
    if(!detector) return;

    // keep canvas matched
    if(canvas.width === 0) resizeCanvas();

    try{
      const poses = await detector.estimatePoses(video, { maxPoses: 1, flipHorizontal: true });
      const pose = poses && poses[0];
      if(pose && pose.keypoints){
        const kps = keypointsToNamed(pose.keypoints);

        drawStickFigure(kps);

        if(isStablePose(kps)) stableCount++;
        else stableCount = 0;

        // gate Start TUG only when stable + tape set
        const stableOk = stableCount >= STABLE_NEED;
        if(stableOk && tapeYNorm !== null){
          setBadge(tugRecording ? "REC" : "READY", tugRecording ? "#b91c1c" : "#16a34a");
          btnStart.disabled = tugRecording ? true : false;
        } else {
          setBadge(tugRecording ? "REC" : "WAIT", tugRecording ? "#b91c1c" : "#b45309");
          btnStart.disabled = true;
        }

        if(tugRecording){
          const tMs = Date.now() - startEpochMs;
          frames.push({
            t_ms: tMs,
            w: canvas.width / devicePixelRatio,
            h: canvas.height / devicePixelRatio,
            keypoints: kps.map(p => ({
              name: p.name,
              x: +(p.x).toFixed(5),
              y: +(p.y).toFixed(5),
              score: +(p.score ?? 0).toFixed(5)
            }))
          });
        }
      }
    } catch(e){
      // keep running; do not crash
    }

    rafId = requestAnimationFrame(loop);
  }

  function armTape(){
    tapeArmed = true;
    setStatus("Tape capture armed: tap ON the blue tape (on the floor) once.", "#b45309");
    btnTape.disabled = true;
    setBadge("TAPE", "#10b981");
  }

  function setTapeFromTap(clientY){
    const rect = canvas.getBoundingClientRect();
    const y = Math.max(0, Math.min(rect.height, (clientY - rect.top)));
    tapeYNorm = y / rect.height;
    tapeArmed = false;
    setStatus(`Tape set. (Saved as meta.tape_y_norm = ${tapeYNorm.toFixed(3)}) Now get subject stable, then Start TUG.`, "#065f46");
  }

  function startTug(){
    if(tapeYNorm === null){
      setStatus("You must Set Tape first.", "#b91c1c");
      return;
    }
    frames = [];
    tugRecording = true;
    startEpochMs = Date.now();
    btnStart.disabled = true;
    setBadge("REC", "#b91c1c");
    setStatus("Recording pose keypoints… Tap Stop at end.", "#b91c1c");
  }

  function stopTug(){
    if(!tugRecording){
      setStatus("Not recording.", "#374151");
      return;
    }
    tugRecording = false;
    setBadge("READY", "#16a34a");
    btnStart.disabled = false;

    const payload = {
      meta: {
        app: "ANVA_TUG_POSE_ONLY",
        version: "privacy_special_v1",
        created_iso: new Date().toISOString(),
        tape_y_norm: +(tapeYNorm.toFixed(6)),
        flip_horizontal: true,
        note: "No video/images saved. Pose keypoints only."
      },
      frames: frames
    };

    const blob = new Blob([JSON.stringify(payload)], { type:"application/json" });
    const a = document.createElement("a");
    a.href = URL.createObjectURL(blob);
    a.download = `ANVA_TUG_KEYPOINTS_${nowIsoCompact()}.json`;
    document.body.appendChild(a);
    a.click();
    a.remove();

    setStatus(`Done. JSON downloaded with meta.tape_y_norm=${tapeYNorm.toFixed(3)}. Upload to Drive for Colab.`, "#065f46");
  }

  // UI wiring
  showVideo.addEventListener('change', () => {
    video.style.display = showVideo.checked ? "block" : "none";
  });

  btnCamera.addEventListener('click', async () => {
    try{
      btnCamera.disabled = true;
      setStatus("Starting camera…", "#374151");
      await startCamera();
    } catch(e){
      btnCamera.disabled = false;
      setBadge("FAIL", "#b91c1c");
      setStatus("Failed to start camera. Refresh and try again.", "#b91c1c");
    }
  });

  btnTape.addEventListener('click', armTape);
  btnStart.addEventListener('click', startTug);
  btnStop.addEventListener('click', stopTug);

  // Tap on canvas to set tape (only when armed)
  canvas.addEventListener('click', (ev) => {
    if(!tapeArmed) return;
    setTapeFromTap(ev.clientY);
    btnTape.disabled = false;
  });

  // Init
  (async () => {
    try{
      setBadge("LOAD", "#374151");
      setStatus("Loading libraries…", "#374151");
      await initDetector();
      setBadge("OK", "#16a34a");
      setStatus("Libraries loaded. Tap Start Camera.", "#065f46");
    } catch(e){
      setBadge("FAIL", "#b91c1c");
      setStatus("Failed to load libraries. Try refreshing.", "#b91c1c");
    }
    // ensure canvas size
    window.addEventListener('resize', resizeCanvas);
    resizeCanvas();
  })();

})();
</script>

</body>
</html>
